# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate 
# (polygonal) numbers and are generated by the following formulae:

# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 			1, 4, 9, 16, 25, ...
# Pentagonal 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two digits of the next 
# number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is 
# represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal 
# type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different 
# number in the set.

triangle_numbers = [0, 1]
while triangle_numbers[-1] < 10000
	triangle_numbers[triangle_numbers.length] = (triangle_numbers.length*(triangle_numbers.length + 1))/2
end
while triangle_numbers[0] < 1000
	triangle_numbers = triangle_numbers[1..-1]
end
triangle_numbers = triangle_numbers[0..-2]

square_numbers = [0, 1]
while square_numbers[-1] < 10000
	square_numbers[square_numbers.length] = square_numbers.length*square_numbers.length
end
while square_numbers[0] < 1000
	square_numbers = square_numbers[1..-1]
end
square_numbers = square_numbers[0..-2]

pentagonal_numbers = [0, 1]
while pentagonal_numbers[-1] < 10000
	pentagonal_numbers[pentagonal_numbers.length] = (pentagonal_numbers.length*(3*pentagonal_numbers.length - 1))/2
end
while pentagonal_numbers[0] < 1000
	pentagonal_numbers = pentagonal_numbers[1..-1]
end
pentagonal_numbers = pentagonal_numbers[0..-2]

hexoganal_numbers = [0, 1]
while hexoganal_numbers[-1] < 10000
	hexoganal_numbers[hexoganal_numbers.length] = hexoganal_numbers.length*((2*hexoganal_numbers.length) - 1)
end
while hexoganal_numbers[0] < 1000
	hexoganal_numbers = hexoganal_numbers[1..-1]
end
hexoganal_numbers = hexoganal_numbers[0..-2]

heptagonal_numbers = [0, 1]
while heptagonal_numbers[-1] < 10000
	heptagonal_numbers[heptagonal_numbers.length] = (heptagonal_numbers.length*((5*heptagonal_numbers.length) - 3))/2
end
while heptagonal_numbers[0] < 1000
	heptagonal_numbers = heptagonal_numbers[1..-1]
end
heptagonal_numbers = heptagonal_numbers[0..-2]

octagonal_numbers = [0, 1]
while octagonal_numbers[-1] < 10000
	octagonal_numbers[octagonal_numbers.length] = octagonal_numbers.length*((3*octagonal_numbers.length) - 2)
end
while octagonal_numbers[0] < 1000
	octagonal_numbers = octagonal_numbers[1..-1]
end
octagonal_numbers = octagonal_numbers[0..-2]

all_numbers = [square_numbers, pentagonal_numbers, hexoganal_numbers, heptagonal_numbers, octagonal_numbers]

all_numbers.permutation.each do |ordering|
	triangle_numbers.each do |tri_number|
		represented = []
		series = [tri_number]
		suffix = tri_number.to_s[-2..-1]
		ordering.each do |number_set|
			number_set.each do |number|
				if (
					number.to_s[0..1] == suffix and
					not represented.include?(ordering.index(number_set))
				)
					suffix = number.to_s[-2..-1]
					represented << ordering.index(number_set)
					series << number
					break
				end
			end
		end
		if (
			represented.sort! == [0, 1, 2, 3, 4] and
			series[-1].to_s[-2..-1] == tri_number.to_s[0..1]
			)
			puts represented
			puts series
			total = 0
			series.each do |number|
				total += number
			end
			puts total
		end
	end
end

# 	square_numbers.each do |quad_number|
# 		if quad_number.to_s[0..1] == tri_suffix
# 			quad_suffix = quad_number.to_s[-2..-1]
# 			pentagonal_numbers.each do |pent_number|
# 				if pent_number.to_s[0..1] == quad_suffix
# 					pent_suffix = pent_number.to_s[-2..-1]
# 					hexoganal_numbers.each do |hex_number|
# 						if hex_number.to_s[0..1] == pent_suffix
# 							hex_suffix = hex_number.to_s[-2..-1]
# 							heptagonal_numbers.each do |hept_number|
# 								if hept_number.to_s[0..1] == hex_suffix
# 									hept_suffix = hept_number.to_s[-2..-1]
# 									octagonal_numbers.each do |oct_number|
# 										if oct_number.to_s[0..1] == hept_suffix
# 											puts [
# 												tri_number, 
# 												quad_number, 
# 												pent_number, 
# 												hex_number, 
# 												hept_number, 
# 												oct_number
# 											]
# 										end
# 									end
# 								end
# 							end
# 						end
# 					end
# 				end
# 			end
# 		end
# 	end
# end

# I'm leaving in the above commented-out code because I'm unusually pleased with it. I wrote it
# as a first draft to get the brain-pump going, and it assumes that each number in the series is pulled
# from the other sets in order (the first is a tri_number, the second is a square number...). It works
# as coded, but doesn't come up with the answer of course. It's super gross too. I just like it.

# Obviously most of the actual code-lines here are devoted to generating the number sets rather
# than finding the actual answer. I wrote it that way to begin with, and it works, so I'm moving along.
# For continuing development, try writing out all the formulae in a single hash like this:
# formulae = {:triangle_numbers => lambda(n) { n*(n+1)/2 }}
# And all of the sequences in a single hash like this:
# sequences = {:triangle_numbers => [0,1], :square_numbers => [0,1]}
# Then you can just do sequences.each do |key, value|; value[n] = formulae[key](value).
# I don't know if that would work, because I'm not sure if you can a) store a lambda in a hash value, or
# pass a loop argument to a lamda like that but it would make this so much prettier.

# I bet this could be done by putting the first number in a hash, with its value as another hash table,
# each of whose keys is a candidate for the next, and so on recursively. Several of the paths in this tree
# will be 6 steps long, and one of those will have the first and the last match up properly, that's the
# answer.
